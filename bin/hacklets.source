HACKLETS_BASEDIR_NAME=.hacklets
HACKLETS_REPODIR_NAME="${HACKLETS_BASEDIR_NAME}/master"
HACKLETS_DIST_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
HACKLETS_EXEC_NAME="${0%/*}"

HACKLETS_PWD=`pwd`
HACKLETS_BASEDIR="${HACKLETS_PWD}/${HACKLETS_BASEDIR_NAME}"
HACKLETS_REPODIR="${HACKLETS_PWD}/${HACKLETS_REPODIR_NAME}"

alias hacklets-init='hacklets_init'
alias hacklets-demo_repos='hacklets_demo_repos'
alias hacklets-new_profile='hacklets_new_profile'
alias h="$HACKLETS_CMD"

LOG_ENABLED="yes"
DONOTLOG="no"
source "$HACKLETS_DIST_DIR/scripts.d/bsfl"
SYSLOG_ENABLED="yes"
DONOTLOG="no"
LOG_FILE="${HACKLETS_BASEDIR}/hacklets.log"
SYSLOG_TAG="hacklets"


function hacklets() {
    #working:
    #   array=( "$@" );
    #   OUT=`cat "${array[@]}"`
    ########
    argv=("$@");
    local HACKLETS_RESULT=`git --git-dir=${HACKLETS_REPODIR} --work-tree=${HACKLETS_PWD} "${argv[@]}" 2>&1`
    local ERROR="$?"

    ############ begin: building the command, preserve quotes around parameters
    # the idea: multi-words params need to be quoted
    local COMMAND="hacklets"
    local SHORT_COMMAND="hacklets"
    for word in "${argv[@]}"; do
        words="${word//[^\ ]} "
        if [[ ${#words} > 1 ]]; then
            local SHORT_COMMAND="$SHORT_COMMAND \"${word:0:32}...\""
            local COMMAND="$COMMAND \"${word}\""
        else
            local SHORT_COMMAND="$SHORT_COMMAND ${word:0:32}"
            local COMMAND="$COMMAND $word"
        fi
    done
    ############ end: building command

    if [[ $ERROR == 0 ]]; then
        msg_ok "${SHORT_COMMAND:0:$[COLUMNS-15]}"
    else
        msg_fail "${SHORT_COMMAND:0:$[COLUMNS-15]}"
    fi
    #TODO long along with this, also $HACKLETS_REPODIR and HACKLETS_PWD
    log "Command: $COMMAND gave: '$HACKLETS_RESULT'"
    if [[ ! -z $HACKLETS_RESULT ]]; then
        echo "-------------------------------------------------------------------------------"
        echo "$HACKLETS_RESULT"
        echo "-------------------------------------------------------------------------------"
    fi
    return "$ERROR"
}
##
# initialize $HACKLETS_REPODIR_NAME (in the CWD) as a hacklets container
# 
# @param alternative CWD
##
function hacklets_init() {
    if [[ ! -z $1 ]]; then
        HACKLETS_PWD="$1"
    else
        HACKLETS_PWD=`pwd`
    fi

    HACKLETS_BASEDIR="${HACKLETS_PWD}/${HACKLETS_BASEDIR_NAME}"
    HACKLETS_REPODIR="${HACKLETS_PWD}/${HACKLETS_REPODIR_NAME}"
    HACKLETS_CMD="git --git-dir=${HACKLETS_REPODIR} --work-tree=${HACKLETS_PWD}"

    cmd "mkdir -p ${HACKLETS_REPODIR}"
    if [[ 0 != $? ]]; then return $?; fi
    cd ${HACKLETS_REPODIR}
    if [[ 0 != $? ]]; then
        msg_fail "cd ${HACKLETS_REPODIR}"
        return $?;
    fi
    msg_ok "cd ${HACKLETS_REPODIR}"
    cmd "git init --bare --template="${HACKLETS_DIST_DIR}/hacklets-template""
    if [[ 0 != $? ]]; then return $?; fi
    cd $HACKLETS_PWD
    msg_ok "cd $HACKLETS_PWD"
}

##
# fetch a hacklet, it's like fetching a repo, but a little bit more twisted (so we maintain flexibility for commads like "hacklet checkout")
##
function hacklet_fetch() {
    if [[ ! -n $1 ]]; then
        msg_fail "first param: URL or name, if name, provide URL as second param"
        return 1;
    fi
    local hname="$1"
    local hurl="$2"
    if [[ -z $hurl ]]; then
        local hurl="${hname}"
        #TODO normalize hurl and set value to hname
        msg_debug "hname: $hname"
        msg_debug "hurl: $hurl"
        msg_fail "TODO"
        return 1
    fi
    cmd "git clone --recursive --bare "${hurl}" "${HACKLETS_BASEDIR}/${hname}.git""
    if [[ 0 != $? ]]; then return $?; fi
    hacklets remote add hacklet/${hname} ${HACKLETS_BASEDIR}/${hname}.git
    if [[ 0 != $? ]]; then return $?; fi
    # TODO the following gives "warning: no common commits", see how you can fix it
    hacklets fetch hacklet/${hname}
    if [[ 0 != $? ]]; then return $?; fi
    hacklets config --local --add remotes.hacklets hacklet/${hname}
    if [[ 0 != $? ]]; then return $?; fi
    return 0
}

function hacklets_update() {
    return 1 # TODO
}

function hacklets_list() {
    hacklets config --local --get-all remotes.hacklets
    return $?
}

##
# create a new empty profile
# 
# @param the name of the profile
##
function hacklets_new_profile() {
    if [[ ! -n $1 ]]; then
        msg_fail "you must supply a profile name"
        return 1;
    fi
    local profname="$1"
    if ! _hacklet_profile_exists "${profname}"; then
        msg_fail "Profile $profname already exists"
        return 1
    fi
    hacklets checkout --orphan profile/${profname}
    if [[ 0 != $? ]]; then return $?; fi
    echo "This is the beginning of profile ${profname}." > "${HACKLETS_PWD}/README.txt"
    hacklets add "${HACKLETS_PWD}/README.txt"
    hacklets commit -q -m "This is the beginning of profile ${profname}"
    hacklets rm -q "${HACKLETS_PWD}/README.txt"
    hacklets commit -q -m "profile ready to be populated with hacklets"
    hacklets tag -a -m "profile $profname" start-$profname
}

##
# adopt an existing (fetched) hacklet into the current profile
##
function hacklet_adopt() {
    eval $(_hacklet_get_active_profile)
    if [[ ! $RETURN ]]; then
        msg_fail "Please activate a profile first"
        unset RETURN
        return 1
    fi
    local profname=$RETURN
    unset RETURN
    if [[ ! -n $1 ]]; then
        msg_fail "adopt <hacklet-name> [hacklet's branch]"
        return 1
    fi
    if [[ ! -n $2 ]]; then
        local branchname="master"
    else
        #TODO check if branch $2 exists
        local branchname="$2"
    fi
    local hname="$1"

    hacklets merge -m "using hacklet/$hname/$branchname in profile $profname" "hacklet/${hname}/${branchname}"
    if [[ -f "${HACKLETS_REPODIR}/MERGE_MSG" ]]; then
        grep -q '^Conflicts:' "${HACKLETS_REPODIR}/MERGE_MSG"
        if [[ 0 == $? ]]; then 
            hacklets mergetool -y
            if [[ 0 == $? ]]; then
                hacklets commit -a
            fi
        fi
    fi
    hacklets tag -a -m "installed $hname" install-$hname
    local HEAD=`${HACKLETS_CMD} rev-parse HEAD`
    hacklets config --local --add profiles.$profname.$hname.$branchname $HEAD
    return 0
}

function hacklet_disown() {
    if [[ ! -n $1 ]]; then
        msg_fail "Please provide a hacklet name"
        return 1
    fi
    local hname="$1"
    eval $(_hacklet_get_active_profile)
    local profname=$RETURN
    if [[ ! $RETURN ]]; then
        msg_fail "Please activate a profile first"
        unset RETURN
        return 1
    fi
    unset RETURN
    local COMMIT=`$HACKLETS_CMD config --local --get-regexp profiles.$profname.$hname.*`
    if [[ 0 != $? ]]; then
        msg_fail "hacklets config --local --get-regexp profiles.$profname.$hname.*"
        return $?;
    fi
    msg_ok "hacklets config --local --get-regexp profiles.$profname.$hname.*"
    #TODO check if 1 == `echo "$COMMIT" | wc -l`, if not, then error
    local COMMIT=`echo "$COMMIT" | cut -d ' ' -f 2`
    hacklets revert -m 1 $COMMIT
}

###############################################################################
# internal function, do not rely on these
###############################################################################
function _hacklet_profile_exists() {
    if [[ 0 != `hacklets branch --no-color --list "profile/$1"` ]]; then
        return 0
    else
        return 1
    fi
}


function _hacklet_get_active_profile() {
    local RETURN=`hacklets branch -a --no-color --list "profile/*" | grep '^* ' | sed 's/* profile\///'`
    if [[ -z $RETURN ]];
        then return 1
    fi
    echo "RETURN="${RETURN}""
    return 0
}

##
# create some testing bare repos in /tmp/hacklets-mocs/*.git/
##

function _hacklets_mock_repo() {
    local name="$1"
    local file="$2"

    cmd "mkdir -p /tmp/hacklets-mocs/checkouts/"
    pushd /tmp/hacklets-mocs/
    mkdir "${name}repo.git"
    cd "${name}repo.git"
    git --bare init
    cd ../checkouts/
    git clone --recursive "../${name}repo.git"
    cd "${name}repo"
    echo "testing $name repo" > $file
    git add $file
    git commit -m "initial commit of $name repo"
    git push origin master
    popd
}
function hacklets_demo_repos() {
    rm -rf /tmp/hacklets-mocs/
    _hacklets_mock_repo first README.txt
    _hacklets_mock_repo second README.txt
    _hacklets_mock_repo third README.txt
    _hacklets_mock_repo unrelated INSTALL.txt
}
